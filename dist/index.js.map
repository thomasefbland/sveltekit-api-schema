{"version":3,"file":"index.js","sources":["../src/core/HTTP_CODES.js","../src/core/api_fetch.js","../src/core/respond.js","../node_modules/.pnpm/zod@3.25.56/node_modules/zod/dist/esm/v4/core/core.js","../node_modules/.pnpm/zod@3.25.56/node_modules/zod/dist/esm/v4/core/util.js","../node_modules/.pnpm/zod@3.25.56/node_modules/zod/dist/esm/v4/core/errors.js","../node_modules/.pnpm/zod@3.25.56/node_modules/zod/dist/esm/v4/classic/errors.js","../src/core/validate.js"],"sourcesContent":["export const OK = 200;\nexport const CREATED = 201;\nexport const NO_CONTENT = 204;\n\nexport const SEE_OTHER = 303;\n\nexport const BAD_REQUEST = 400;\nexport const UNAUTHORIZED = 401;\nexport const FORBIDDEN = 403;\nexport const NOT_FOUND = 404;\n\nexport const SERVER_ERROR = 500;\n","/**\n * @typedef {Object} UnwrappedSuccessfulResponse\n * @property {true} ok\n * @property {Record<string, any>} json\n */\n\n/**\n * @typedef {Object} UnwrappedFailedResponse\n * @property {false} ok\n * @property {{ message: string }} json\n */\n\n/**\n * @typedef {UnwrappedSuccessfulResponse | UnwrappedFailedResponse} UnwrappedResponse\n */\n\n/**\n * @callback SvelteFetch\n * @param {RequestInfo | URL | string | globalThis.Request} input\n * @param {RequestInit} [init]\n * @returns {Promise<Response>}\n */\n\n/**\n * @typedef {'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'} Method\n */\n\n// FIXME: This interface is pretty bad probably now that I think about itx\n/**\n * @template {Record<string, any>} Data\n * @param {string} route\n * @param {Method} method\n * @param {Record<string, any> | SvelteFetch} [payload_or_svelte_fetch]\n * @param {SvelteFetch} [svelte_fetch]\n * @returns {Promise<UnwrappedResponse & { json: Data }>}\n */\nexport async function api_fetch(route, method, payload_or_svelte_fetch, svelte_fetch) {\n\tconst _fetch = svelte_fetch ?? (typeof payload_or_svelte_fetch !== \"function\" ? fetch : payload_or_svelte_fetch);\n\n\tconst payload = typeof payload_or_svelte_fetch === \"object\" && !Array.isArray(payload_or_svelte_fetch) ? payload_or_svelte_fetch : undefined;\n\n\treturn new Promise((resolve) => {\n\t\t_fetch(route, {\n\t\t\tmethod: method,\n\t\t\tbody: payload ? JSON.stringify(payload) : undefined,\n\t\t}).then((/** @type {Response} */ response) => response.json().then((json) => resolve({ ok: response.ok, json })));\n\t});\n}\n","import { NO_CONTENT } from \"./HTTP_CODES.js\";\n\n/**\n * @typedef {200 | 201 | 204 | 400 | 401 | 403 | 404 | 500} ApiHttpCode\n */\n\n/**\n * @type {Record<ApiHttpCode, string>}\n */\nconst DEFAULT_MESSAGES = {\n\t200: \"OK\",\n\t201: \"Created\",\n\t204: \"No Content\",\n\t400: \"Bad Request\",\n\t401: \"Unauthorized\",\n\t403: \"Forbidden\",\n\t404: \"Not Found\",\n\t500: \"Internal Server Error\",\n};\n\n/**\n * @typedef {Record<string, any>} Dict\n */\n\n/**\n * @typedef {Response & {\n *   ok: true,\n *   json: () => Promise<Dict>\n * }} SuccessfulAPIResponse\n */\n\n/**\n * @typedef {Response & {\n *   ok: false\n * }} FailedAPIResponse\n */\n\n/**\n * @typedef {SuccessfulAPIResponse | FailedAPIResponse} APIResponseWithoutData\n */\n\n/**\n * @template T\n * @typedef {SuccessfulAPIResponse & { json(): Promise<T> } | FailedAPIResponse} APIResponseWithData\n */\n\n/**\n * Respond with just a status code.\n * @param {ApiHttpCode} status_code\n * @returns {Promise<APIResponseWithoutData>}\n */\n\n/**\n * Respond with a status code and message.\n * @param {ApiHttpCode} status_code\n * @param {string} message_or_data\n * @returns {Promise<APIResponseWithoutData>}\n */\n\n/**\n * @template {Dict} Data\n * Respond with status code, message, and data.\n * @param {ApiHttpCode} status_code\n * @param {string} message_or_data\n * @param {Data} data\n * @returns {Promise<APIResponseWithData<{ message: string; data: Data }>>}\n */\n\n/**\n * @template {Dict} Data\n * Respond with status code and data (auto-message).\n * @param {ApiHttpCode} status_code\n * @param {Data} message_or_data\n * @returns {Promise<APIResponseWithData<{ message: string; data: Data }>>}\n */\n\n/**\n * @template {Dict} Data\n * @param {ApiHttpCode} status_code\n * @param {string | Data} [message_or_data]\n * @param {Data} [data]\n * @returns {Promise<APIResponseWithData<any> | APIResponseWithoutData>}\n */\nexport async function respond(status_code, message_or_data, data) {\n\tif (status_code === NO_CONTENT) return new Response(null, { status: NO_CONTENT });\n\n\tif (message_or_data !== undefined) {\n\t\tif (typeof message_or_data === \"string\") {\n\t\t\tif (data) {\n\t\t\t\treturn build_response(status_code, message_or_data, data);\n\t\t\t} else {\n\t\t\t\treturn build_response(status_code, message_or_data);\n\t\t\t}\n\t\t} else {\n\t\t\treturn build_response(status_code, DEFAULT_MESSAGES[status_code], message_or_data);\n\t\t}\n\t} else {\n\t\treturn build_response(status_code, DEFAULT_MESSAGES[status_code]);\n\t}\n}\n\n/**\n *\n * @template {Dict} Data\n * @param {ApiHttpCode} status_code\n * @param {string} message\n * @param {Data} [data]\n * @returns {Response}\n */\nfunction build_response(status_code, message, data) {\n\tconst body = { message: message };\n\t// @ts-ignore\n\tif (data) body[\"data\"] = data;\n\n\treturn new Response(JSON.stringify(body), { status: status_code, headers: { \"Content-Type\": \"application/json\" } });\n}\n","export /*@__NO_SIDE_EFFECTS__*/ function $constructor(name, initializer, params) {\n    function init(inst, def) {\n        var _a;\n        Object.defineProperty(inst, \"_zod\", {\n            value: inst._zod ?? {},\n            enumerable: false,\n        });\n        (_a = inst._zod).traits ?? (_a.traits = new Set());\n        inst._zod.traits.add(name);\n        initializer(inst, def);\n        // support prototype modifications\n        for (const k in _.prototype) {\n            if (!(k in inst))\n                Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n        }\n        inst._zod.constr = _;\n        inst._zod.def = def;\n    }\n    // doesn't work if Parent has a constructor with arguments\n    const Parent = params?.Parent ?? Object;\n    class Definition extends Parent {\n    }\n    Object.defineProperty(Definition, \"name\", { value: name });\n    function _(def) {\n        var _a;\n        const inst = params?.Parent ? new Definition() : this;\n        init(inst, def);\n        (_a = inst._zod).deferred ?? (_a.deferred = []);\n        for (const fn of inst._zod.deferred) {\n            fn();\n        }\n        return inst;\n    }\n    Object.defineProperty(_, \"init\", { value: init });\n    Object.defineProperty(_, Symbol.hasInstance, {\n        value: (inst) => {\n            if (params?.Parent && inst instanceof params.Parent)\n                return true;\n            return inst?._zod?.traits?.has(name);\n        },\n    });\n    Object.defineProperty(_, \"name\", { value: name });\n    return _;\n}\n//////////////////////////////   UTILITIES   ///////////////////////////////////////\nexport const $brand = Symbol(\"zod_brand\");\nexport class $ZodAsyncError extends Error {\n    constructor() {\n        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n    }\n}\nexport const globalConfig = {};\nexport function config(newConfig) {\n    if (newConfig)\n        Object.assign(globalConfig, newConfig);\n    return globalConfig;\n}\n","// functions\nexport function assertEqual(val) {\n    return val;\n}\nexport function assertNotEqual(val) {\n    return val;\n}\nexport function assertIs(_arg) { }\nexport function assertNever(_x) {\n    throw new Error();\n}\nexport function assert(_) { }\nexport function getEnumValues(entries) {\n    const numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n    const values = Object.entries(entries)\n        .filter(([k, _]) => numericValues.indexOf(+k) === -1)\n        .map(([_, v]) => v);\n    return values;\n}\nexport function joinValues(array, separator = \"|\") {\n    return array.map((val) => stringifyPrimitive(val)).join(separator);\n}\nexport function jsonStringifyReplacer(_, value) {\n    if (typeof value === \"bigint\")\n        return value.toString();\n    return value;\n}\nexport function cached(getter) {\n    const set = false;\n    return {\n        get value() {\n            if (!set) {\n                const value = getter();\n                Object.defineProperty(this, \"value\", { value });\n                return value;\n            }\n            throw new Error(\"cached value already set\");\n        },\n    };\n}\nexport function nullish(input) {\n    return input === null || input === undefined;\n}\nexport function cleanRegex(source) {\n    const start = source.startsWith(\"^\") ? 1 : 0;\n    const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n    return source.slice(start, end);\n}\nexport function floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport function defineLazy(object, key, getter) {\n    const set = false;\n    Object.defineProperty(object, key, {\n        get() {\n            if (!set) {\n                const value = getter();\n                object[key] = value;\n                return value;\n            }\n            throw new Error(\"cached value already set\");\n        },\n        set(v) {\n            Object.defineProperty(object, key, {\n                value: v,\n                // configurable: true,\n            });\n            // object[key] = v;\n        },\n        configurable: true,\n    });\n}\nexport function assignProp(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    });\n}\nexport function getElementAtPath(obj, path) {\n    if (!path)\n        return obj;\n    return path.reduce((acc, key) => acc?.[key], obj);\n}\nexport function promiseAllObject(promisesObj) {\n    const keys = Object.keys(promisesObj);\n    const promises = keys.map((key) => promisesObj[key]);\n    return Promise.all(promises).then((results) => {\n        const resolvedObj = {};\n        for (let i = 0; i < keys.length; i++) {\n            resolvedObj[keys[i]] = results[i];\n        }\n        return resolvedObj;\n    });\n}\nexport function randomString(length = 10) {\n    const chars = \"abcdefghijklmnopqrstuvwxyz\";\n    let str = \"\";\n    for (let i = 0; i < length; i++) {\n        str += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return str;\n}\nexport function esc(str) {\n    return JSON.stringify(str);\n}\nexport function isObject(data) {\n    return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nexport const allowsEval = cached(() => {\n    try {\n        const F = Function;\n        new F(\"\");\n        return true;\n    }\n    catch (_) {\n        return false;\n    }\n});\nfunction _isObject(o) {\n    return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nexport function isPlainObject(o) {\n    if (isObject(o) === false)\n        return false;\n    // modified constructor\n    const ctor = o.constructor;\n    if (ctor === undefined)\n        return true;\n    // modified prototype\n    const prot = ctor.prototype;\n    if (isObject(prot) === false)\n        return false;\n    // ctor doesn't have static `isPrototypeOf`\n    if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n        return false;\n    }\n    return true;\n}\nexport function numKeys(data) {\n    let keyCount = 0;\n    for (const key in data) {\n        if (Object.prototype.hasOwnProperty.call(data, key)) {\n            keyCount++;\n        }\n    }\n    return keyCount;\n}\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return \"undefined\";\n        case \"string\":\n            return \"string\";\n        case \"number\":\n            return Number.isNaN(data) ? \"nan\" : \"number\";\n        case \"boolean\":\n            return \"boolean\";\n        case \"function\":\n            return \"function\";\n        case \"bigint\":\n            return \"bigint\";\n        case \"symbol\":\n            return \"symbol\";\n        case \"object\":\n            if (Array.isArray(data)) {\n                return \"array\";\n            }\n            if (data === null) {\n                return \"null\";\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return \"promise\";\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return \"map\";\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return \"set\";\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return \"date\";\n            }\n            if (typeof File !== \"undefined\" && data instanceof File) {\n                return \"file\";\n            }\n            return \"object\";\n        default:\n            throw new Error(`Unknown data type: ${t}`);\n    }\n};\nexport const propertyKeyTypes = new Set([\"string\", \"number\", \"symbol\"]);\nexport const primitiveTypes = new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nexport function escapeRegex(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n// zod-specific utils\nexport function clone(inst, def, params) {\n    const cl = new inst._zod.constr(def ?? inst._zod.def);\n    if (!def || params?.parent)\n        cl._zod.parent = inst;\n    return cl;\n}\nexport function normalizeParams(_params) {\n    const params = _params;\n    if (!params)\n        return {};\n    if (typeof params === \"string\")\n        return { error: () => params };\n    if (params?.message !== undefined) {\n        if (params?.error !== undefined)\n            throw new Error(\"Cannot specify both `message` and `error` params\");\n        params.error = params.message;\n    }\n    delete params.message;\n    if (typeof params.error === \"string\")\n        return { ...params, error: () => params.error };\n    return params;\n}\nexport function createTransparentProxy(getter) {\n    let target;\n    return new Proxy({}, {\n        get(_, prop, receiver) {\n            target ?? (target = getter());\n            return Reflect.get(target, prop, receiver);\n        },\n        set(_, prop, value, receiver) {\n            target ?? (target = getter());\n            return Reflect.set(target, prop, value, receiver);\n        },\n        has(_, prop) {\n            target ?? (target = getter());\n            return Reflect.has(target, prop);\n        },\n        deleteProperty(_, prop) {\n            target ?? (target = getter());\n            return Reflect.deleteProperty(target, prop);\n        },\n        ownKeys(_) {\n            target ?? (target = getter());\n            return Reflect.ownKeys(target);\n        },\n        getOwnPropertyDescriptor(_, prop) {\n            target ?? (target = getter());\n            return Reflect.getOwnPropertyDescriptor(target, prop);\n        },\n        defineProperty(_, prop, descriptor) {\n            target ?? (target = getter());\n            return Reflect.defineProperty(target, prop, descriptor);\n        },\n    });\n}\nexport function stringifyPrimitive(value) {\n    if (typeof value === \"bigint\")\n        return value.toString() + \"n\";\n    if (typeof value === \"string\")\n        return `\"${value}\"`;\n    return `${value}`;\n}\nexport function optionalKeys(shape) {\n    return Object.keys(shape).filter((k) => {\n        return shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n    });\n}\nexport const NUMBER_FORMAT_RANGES = {\n    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n    int32: [-2147483648, 2147483647],\n    uint32: [0, 4294967295],\n    float32: [-3.4028234663852886e38, 3.4028234663852886e38],\n    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],\n};\nexport const BIGINT_FORMAT_RANGES = {\n    int64: [/* @__PURE__*/ BigInt(\"-9223372036854775808\"), /* @__PURE__*/ BigInt(\"9223372036854775807\")],\n    uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt(\"18446744073709551615\")],\n};\nexport function pick(schema, mask) {\n    const newShape = {};\n    const currDef = schema._zod.def; //.shape;\n    for (const key in mask) {\n        if (!(key in currDef.shape)) {\n            throw new Error(`Unrecognized key: \"${key}\"`);\n        }\n        if (!mask[key])\n            continue;\n        // pick key\n        newShape[key] = currDef.shape[key];\n    }\n    return clone(schema, {\n        ...schema._zod.def,\n        shape: newShape,\n        checks: [],\n    });\n}\nexport function omit(schema, mask) {\n    const newShape = { ...schema._zod.def.shape };\n    const currDef = schema._zod.def; //.shape;\n    for (const key in mask) {\n        if (!(key in currDef.shape)) {\n            throw new Error(`Unrecognized key: \"${key}\"`);\n        }\n        if (!mask[key])\n            continue;\n        delete newShape[key];\n    }\n    return clone(schema, {\n        ...schema._zod.def,\n        shape: newShape,\n        checks: [],\n    });\n}\nexport function extend(schema, shape) {\n    const def = {\n        ...schema._zod.def,\n        get shape() {\n            const _shape = { ...schema._zod.def.shape, ...shape };\n            assignProp(this, \"shape\", _shape); // self-caching\n            return _shape;\n        },\n        checks: [], // delete existing checks\n    };\n    return clone(schema, def);\n}\nexport function merge(a, b) {\n    return clone(a, {\n        ...a._zod.def,\n        get shape() {\n            const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n            assignProp(this, \"shape\", _shape); // self-caching\n            return _shape;\n        },\n        catchall: b._zod.def.catchall,\n        checks: [], // delete existing checks\n    });\n}\nexport function partial(Class, schema, mask) {\n    const oldShape = schema._zod.def.shape;\n    const shape = { ...oldShape };\n    if (mask) {\n        for (const key in mask) {\n            if (!(key in oldShape)) {\n                throw new Error(`Unrecognized key: \"${key}\"`);\n            }\n            if (!mask[key])\n                continue;\n            shape[key] = Class\n                ? new Class({\n                    type: \"optional\",\n                    innerType: oldShape[key],\n                })\n                : oldShape[key];\n        }\n    }\n    else {\n        for (const key in oldShape) {\n            shape[key] = Class\n                ? new Class({\n                    type: \"optional\",\n                    innerType: oldShape[key],\n                })\n                : oldShape[key];\n        }\n    }\n    return clone(schema, {\n        ...schema._zod.def,\n        shape,\n        checks: [],\n    });\n}\nexport function required(Class, schema, mask) {\n    const oldShape = schema._zod.def.shape;\n    const shape = { ...oldShape };\n    if (mask) {\n        for (const key in mask) {\n            if (!(key in shape)) {\n                throw new Error(`Unrecognized key: \"${key}\"`);\n            }\n            if (!mask[key])\n                continue;\n            // overwrite with non-optional\n            shape[key] = new Class({\n                type: \"nonoptional\",\n                innerType: oldShape[key],\n            });\n        }\n    }\n    else {\n        for (const key in oldShape) {\n            // overwrite with non-optional\n            shape[key] = new Class({\n                type: \"nonoptional\",\n                innerType: oldShape[key],\n            });\n        }\n    }\n    return clone(schema, {\n        ...schema._zod.def,\n        shape,\n        // optional: [],\n        checks: [],\n    });\n}\nexport function aborted(x, startIndex = 0) {\n    for (let i = startIndex; i < x.issues.length; i++) {\n        if (x.issues[i].continue !== true)\n            return true;\n    }\n    return false;\n}\nexport function prefixIssues(path, issues) {\n    return issues.map((iss) => {\n        var _a;\n        (_a = iss).path ?? (_a.path = []);\n        iss.path.unshift(path);\n        return iss;\n    });\n}\nexport function unwrapMessage(message) {\n    return typeof message === \"string\" ? message : message?.message;\n}\nexport function finalizeIssue(iss, ctx, config) {\n    const full = { ...iss, path: iss.path ?? [] };\n    // for backwards compatibility\n    if (!iss.message) {\n        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??\n            unwrapMessage(ctx?.error?.(iss)) ??\n            unwrapMessage(config.customError?.(iss)) ??\n            unwrapMessage(config.localeError?.(iss)) ??\n            \"Invalid input\";\n        full.message = message;\n    }\n    // delete (full as any).def;\n    delete full.inst;\n    delete full.continue;\n    if (!ctx?.reportInput) {\n        delete full.input;\n    }\n    return full;\n}\nexport function getSizableOrigin(input) {\n    if (input instanceof Set)\n        return \"set\";\n    if (input instanceof Map)\n        return \"map\";\n    if (input instanceof File)\n        return \"file\";\n    return \"unknown\";\n}\nexport function getLengthableOrigin(input) {\n    if (Array.isArray(input))\n        return \"array\";\n    if (typeof input === \"string\")\n        return \"string\";\n    return \"unknown\";\n}\nexport function issue(...args) {\n    const [iss, input, inst] = args;\n    if (typeof iss === \"string\") {\n        return {\n            message: iss,\n            code: \"custom\",\n            input,\n            inst,\n        };\n    }\n    return { ...iss };\n}\nexport function cleanEnum(obj) {\n    return Object.entries(obj)\n        .filter(([k, _]) => {\n        // return true if NaN, meaning it's not a number, thus a string key\n        return Number.isNaN(Number.parseInt(k, 10));\n    })\n        .map((el) => el[1]);\n}\n// instanceof\nexport class Class {\n    constructor(..._args) { }\n}\n","import { $constructor } from \"./core.js\";\nimport * as util from \"./util.js\";\nconst initializer = (inst, def) => {\n    inst.name = \"$ZodError\";\n    Object.defineProperty(inst, \"_zod\", {\n        value: inst._zod,\n        enumerable: false,\n    });\n    Object.defineProperty(inst, \"issues\", {\n        value: def,\n        enumerable: false,\n    });\n    Object.defineProperty(inst, \"message\", {\n        get() {\n            return JSON.stringify(def, util.jsonStringifyReplacer, 2);\n        },\n        enumerable: true,\n        // configurable: false,\n    });\n};\nexport const $ZodError = $constructor(\"$ZodError\", initializer);\nexport const $ZodRealError = $constructor(\"$ZodError\", initializer, { Parent: Error });\nexport function flattenError(error, mapper = (issue) => issue.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of error.issues) {\n        if (sub.path.length > 0) {\n            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n            fieldErrors[sub.path[0]].push(mapper(sub));\n        }\n        else {\n            formErrors.push(mapper(sub));\n        }\n    }\n    return { formErrors, fieldErrors };\n}\nexport function formatError(error, _mapper) {\n    const mapper = _mapper ||\n        function (issue) {\n            return issue.message;\n        };\n    const fieldErrors = { _errors: [] };\n    const processError = (error) => {\n        for (const issue of error.issues) {\n            if (issue.code === \"invalid_union\" && issue.errors.length) {\n                issue.errors.map((issues) => processError({ issues }));\n            }\n            else if (issue.code === \"invalid_key\") {\n                processError({ issues: issue.issues });\n            }\n            else if (issue.code === \"invalid_element\") {\n                processError({ issues: issue.issues });\n            }\n            else if (issue.path.length === 0) {\n                fieldErrors._errors.push(mapper(issue));\n            }\n            else {\n                let curr = fieldErrors;\n                let i = 0;\n                while (i < issue.path.length) {\n                    const el = issue.path[i];\n                    const terminal = i === issue.path.length - 1;\n                    if (!terminal) {\n                        curr[el] = curr[el] || { _errors: [] };\n                    }\n                    else {\n                        curr[el] = curr[el] || { _errors: [] };\n                        curr[el]._errors.push(mapper(issue));\n                    }\n                    curr = curr[el];\n                    i++;\n                }\n            }\n        }\n    };\n    processError(error);\n    return fieldErrors;\n}\nexport function treeifyError(error, _mapper) {\n    const mapper = _mapper ||\n        function (issue) {\n            return issue.message;\n        };\n    const result = { errors: [] };\n    const processError = (error, path = []) => {\n        var _a, _b;\n        for (const issue of error.issues) {\n            if (issue.code === \"invalid_union\" && issue.errors.length) {\n                // regular union error\n                issue.errors.map((issues) => processError({ issues }, issue.path));\n            }\n            else if (issue.code === \"invalid_key\") {\n                processError({ issues: issue.issues }, issue.path);\n            }\n            else if (issue.code === \"invalid_element\") {\n                processError({ issues: issue.issues }, issue.path);\n            }\n            else {\n                const fullpath = [...path, ...issue.path];\n                if (fullpath.length === 0) {\n                    result.errors.push(mapper(issue));\n                    continue;\n                }\n                let curr = result;\n                let i = 0;\n                while (i < fullpath.length) {\n                    const el = fullpath[i];\n                    const terminal = i === fullpath.length - 1;\n                    if (typeof el === \"string\") {\n                        curr.properties ?? (curr.properties = {});\n                        (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });\n                        curr = curr.properties[el];\n                    }\n                    else {\n                        curr.items ?? (curr.items = []);\n                        (_b = curr.items)[el] ?? (_b[el] = { errors: [] });\n                        curr = curr.items[el];\n                    }\n                    if (terminal) {\n                        curr.errors.push(mapper(issue));\n                    }\n                    i++;\n                }\n            }\n        }\n    };\n    processError(error);\n    return result;\n}\n/** Format a ZodError as a human-readable string in the following form.\n *\n * From\n *\n * ```ts\n * ZodError {\n *   issues: [\n *     {\n *       expected: 'string',\n *       code: 'invalid_type',\n *       path: [ 'username' ],\n *       message: 'Invalid input: expected string'\n *     },\n *     {\n *       expected: 'number',\n *       code: 'invalid_type',\n *       path: [ 'favoriteNumbers', 1 ],\n *       message: 'Invalid input: expected number'\n *     }\n *   ];\n * }\n * ```\n *\n * to\n *\n * ```\n * username\n *   ✖ Expected number, received string at \"username\n * favoriteNumbers[0]\n *   ✖ Invalid input: expected number\n * ```\n */\nexport function toDotPath(path) {\n    const segs = [];\n    for (const seg of path) {\n        if (typeof seg === \"number\")\n            segs.push(`[${seg}]`);\n        else if (typeof seg === \"symbol\")\n            segs.push(`[${JSON.stringify(String(seg))}]`);\n        else if (/[^\\w$]/.test(seg))\n            segs.push(`[${JSON.stringify(seg)}]`);\n        else {\n            if (segs.length)\n                segs.push(\".\");\n            segs.push(seg);\n        }\n    }\n    return segs.join(\"\");\n}\nexport function prettifyError(error) {\n    const lines = [];\n    // sort by path length\n    const issues = [...error.issues].sort((a, b) => a.path.length - b.path.length);\n    // Process each issue\n    for (const issue of issues) {\n        lines.push(`✖ ${issue.message}`);\n        if (issue.path?.length)\n            lines.push(`  → at ${toDotPath(issue.path)}`);\n    }\n    // Convert Map to formatted string\n    return lines.join(\"\\n\");\n}\n","import * as core from \"zod/v4/core\";\nimport { $ZodError } from \"zod/v4/core\";\nconst initializer = (inst, issues) => {\n    $ZodError.init(inst, issues);\n    inst.name = \"ZodError\";\n    Object.defineProperties(inst, {\n        format: {\n            value: (mapper) => core.formatError(inst, mapper),\n            // enumerable: false,\n        },\n        flatten: {\n            value: (mapper) => core.flattenError(inst, mapper),\n            // enumerable: false,\n        },\n        addIssue: {\n            value: (issue) => inst.issues.push(issue),\n            // enumerable: false,\n        },\n        addIssues: {\n            value: (issues) => inst.issues.push(...issues),\n            // enumerable: false,\n        },\n        isEmpty: {\n            get() {\n                return inst.issues.length === 0;\n            },\n            // enumerable: false,\n        },\n    });\n    // Object.defineProperty(inst, \"isEmpty\", {\n    //   get() {\n    //     return inst.issues.length === 0;\n    //   },\n    // });\n};\nexport const ZodError = core.$constructor(\"ZodError\", initializer);\nexport const ZodRealError = core.$constructor(\"ZodError\", initializer, {\n    Parent: Error,\n});\n// /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */\n// export type ErrorMapCtx = core.$ZodErrorMapCtx;\n","import { ZodError } from \"zod/v4\";\n\n/**\n * @template {import('zod/v4').ZodObject} Payload\n * @typedef {{ success: true; payload: import('zod/v4').infer<Payload>; error: undefined }} Valid<Payload>\n */\n\n/**\n * @template {import('zod/v4').ZodObject} Payload\n * @typedef {{ success: false; payload: undefined; error: import('zod/v4').ZodError<import('zod/v4').infer<Payload>> }} Invalid<Payload>\n */\n\n/**\n *\n * @template {import('zod/v4').ZodObject} Schema\n * @param {Request} request\n * @param {Schema} schema\n * @returns {Promise<Valid<Schema> | Invalid<Schema>>}\n */\nexport async function validate(request, schema) {\n\ttry {\n\t\tconst json = await request.json();\n\t\tconst { success, data, error } = schema.safeParse(json);\n\n\t\tif (success) {\n\t\t\treturn {\n\t\t\t\tsuccess,\n\t\t\t\tpayload: data,\n\t\t\t\terror,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tsuccess,\n\t\t\t\tpayload: data,\n\t\t\t\terror,\n\t\t\t};\n\t\t}\n\t} catch {\n\t\tconst error = /** @type {import('zod/v4').ZodError<import('zod/v4').output<Schema>>} */ (\n\t\t\tnew ZodError([\n\t\t\t\t{\n\t\t\t\t\tcode: \"custom\",\n\t\t\t\t\tinput: undefined,\n\t\t\t\t\tmessage: \"Invalid JSON in request body\",\n\t\t\t\t\tpath: [],\n\t\t\t\t},\n\t\t\t])\n\t\t);\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\tpayload: undefined,\n\t\t\terror,\n\t\t};\n\t}\n}\n"],"names":["initializer","util.jsonStringifyReplacer","core.formatError","core.flattenError","core.$constructor"],"mappings":"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","x_google_ignoreList":[3,4,5,6]}